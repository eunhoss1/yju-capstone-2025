<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>LoadMate: Robot Automation Sim</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            color: #fff;
            font-family: 'Pretendard', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        h1 {
            margin: 0;
            font-size: 2em;
            color: #4fc3f7;
            letter-spacing: -1px;
        }
        p {
            margin: 5px 0;
            color: #b0bec5;
            font-size: 1.05em;
        }
        #status {
            color: #ffeb3b;
            font-weight: bold;
            font-size: 1.15em;
            margin-top: 10px;
        }
    </style>
</head>
<body>
<div id="info">
    <h1>Phase 2: 로봇 자동 적재 시뮬레이션</h1>
    <p>AI 좌표 데이터(X, Y, Z) 기반 무인 상차 시스템</p>
    <p id="status">Status: 시스템 초기화 중...</p>
</div>

<!-- 라이브러리 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

<script>
    let scene, camera, renderer, controls;
    let robotBase, robotArm1, robotArm2, robotHand;
    let truckBed;
    const boxes = [];
    let currentBoxIndex = 0;

    // ✅ 적재 좌표 데이터 (LIFO 순서) - 한 객체로 평탄화
    const loadData = [
        { w:1, h:1, d:1, x:-1, y:0.5, z:-2, color:0xff5722 },
        { w:1, h:1, d:1, x: 0, y:0.5, z:-2, color:0xff5722 },
        { w:1, h:1, d:1, x: 1, y:0.5, z:-2, color:0xff5722 },

        { w:1, h:1, d:1, x:-1, y:0.5, z:-1, color:0xffeb3b },
        { w:1, h:1, d:1, x: 0, y:1.5, z:-2, color:0x03a9f4 },
        { w:1, h:1, d:1, x: 1, y:0.5, z:-1, color:0xffeb3b },

        { w:1, h:1, d:1, x:-1, y:0.5, z: 0, color:0x4caf50 },
        { w:1, h:1, d:1, x: 0, y:0.5, z: 0, color:0x4caf50 },
        { w:1, h:1, d:1, x: 1, y:0.5, z: 0, color:0x4caf50 }
    ];

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        // 조명
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // 카메라
        camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(6, 6, 8);
        camera.lookAt(0, 0, 0);

        // 렌더러
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // OrbitControls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // 바닥 그리드
        const grid = new THREE.GridHelper(20, 20, 0x333333, 0x333333);
        scene.add(grid);

        createEnvironment();
        createRobot();

        window.addEventListener('resize', onWindowResize);

        // 1초 후 시뮬레이션 시작
        setTimeout(startSimulation, 1000);
    }

    function createEnvironment() {
        // 트럭 적재함
        const truckGeo = new THREE.BoxGeometry(3.5, 0.2, 5);
        const truckMat = new THREE.MeshPhongMaterial({ color: 0x424242 });
        truckBed = new THREE.Mesh(truckGeo, truckMat);
        truckBed.position.set(0, 0, -1);
        truckBed.receiveShadow = true;
        scene.add(truckBed);

        // 컨베이어 벨트
        const beltGeo = new THREE.BoxGeometry(2, 0.5, 4);
        const beltMat = new THREE.MeshPhongMaterial({ color: 0x263238 });
        const belt = new THREE.Mesh(beltGeo, beltMat);
        belt.position.set(-4, 0.25, 2);
        belt.receiveShadow = true;
        scene.add(belt);
    }

    function createRobot() {
        const robotMat = new THREE.MeshPhongMaterial({ color: 0xe0e0e0 });
        const jointMat = new THREE.MeshPhongMaterial({ color: 0x1976d2 });

        // 로봇 베이스
        robotBase = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, 0.5, 32),
            robotMat
        );
        robotBase.position.set(-4, 0.25, -2);
        scene.add(robotBase);

        // 하단 팔
        robotArm1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 3, 0.5),
            robotMat
        );
        robotArm1.position.set(0, 1.5, 0);
        robotBase.add(robotArm1);

        // 관절
        const joint = new THREE.Mesh(
            new THREE.SphereGeometry(0.4),
            jointMat
        );
        joint.position.set(0, 1.5, 0);
        robotArm1.add(joint);

        // 상단 팔
        robotArm2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 2.5, 0.4),
            robotMat
        );
        robotArm2.position.set(0, 1.25, 0);
        joint.add(robotArm2);

        // 손
        robotHand = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.2, 0.6),
            jointMat
        );
        robotHand.position.set(0, 1.25, 0);
        robotArm2.add(robotHand);
    }

    function createBox(data) {
        const geometry = new THREE.BoxGeometry(data.w, data.h, data.d);
        const material = new THREE.MeshPhongMaterial({ color: data.color });
        const box = new THREE.Mesh(geometry, material);
        box.castShadow = true;

        // 시작 위치 (컨베이어 끝)
        box.position.set(-4, 0.75, 3.5);
        scene.add(box);
        return box;
    }

    function startSimulation() {
        const statusEl = document.getElementById('status');

        if (currentBoxIndex >= loadData.length) {
            statusEl.innerText = "Status: 모든 적재 완료 (Mission Complete)";
            statusEl.style.color = "#4caf50";
            return;
        }

        const data = loadData[currentBoxIndex];
        const targetPos = { x: data.x, y: data.y, z: data.z };

        statusEl.innerText =
            `Status: 박스 ${currentBoxIndex + 1}/${loadData.length} 이동 중...`;

        const box = createBox(data);
        boxes.push(box);

        // GSAP 타임라인
        const tl = gsap.timeline({ onComplete: startSimulation });

        // 1. 집으러 가기
        tl.to(robotBase.rotation, {
            y: Math.PI / 2,
            duration: 0.6,
            ease: "power2.inOut"
        })
        .to(robotArm1.rotation, {
            z: -Math.PI / 4,
            duration: 0.6,
            ease: "power2.inOut"
        }, "<")
        .to(robotArm2.rotation, {
            z: Math.PI / 2,
            duration: 0.6,
            ease: "power2.inOut"
        }, "<");

        // 2. 집기
        tl.call(() => {
            robotHand.add(box);
            box.position.set(0, -0.6, 0);
        });

        // 3. 목표 위치로 회전
        const angleY = Math.atan2(
            targetPos.x - robotBase.position.x,
            targetPos.z - robotBase.position.z
        );

        tl.to(robotBase.rotation, {
            y: angleY,
            duration: 0.8,
            ease: "power2.inOut"
        })
        .to(robotArm1.rotation, {
            z: Math.PI / 6,
            duration: 0.8,
            ease: "power2.inOut"
        }, "<")
        .to(robotArm2.rotation, {
            z: -Math.PI / 6,
            duration: 0.8,
            ease: "power2.inOut"
        }, "<");

        // 4. 내려놓기
        tl.call(() => {
            scene.add(box);
            box.position.set(targetPos.x, targetPos.y, targetPos.z);
            box.rotation.set(0, 0, 0);
        });

        // 5. 복귀
        tl.to(robotArm1.rotation, {
            z: -Math.PI / 4,
            duration: 0.5,
            ease: "power2.inOut"
        })
        .to(robotArm2.rotation, {
            z: Math.PI / 2,
            duration: 0.5,
            ease: "power2.inOut"
        }, "<");

        currentBoxIndex++;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    init();
    animate();
</script>
</body>
</html>
